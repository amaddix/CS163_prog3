# CS163_prog3 2018


What functions your ADT will need to have
I will fist need a hash function in order to convert the key word passed in, into a number to be used as the index of my hash array. A method I’m considering using to create my index, is by using the definition term as my keyword. Then I will add each character of the keyword together to get a larger number. After that I will use the mod operator to get a remainder to be the index. I will probably use a larger prime number to mod to keyword’s sum. 
I will also have a function to add a new definition (and all the information included with it) into the hash table. To do this I will call my hash function to to get my index, and save that index into a variable (called index). I will then save the new definition information into a temp node. And set its next to be the arrays head (array[index]), Then I will assign the arrays head to be temp.
I will have a function to retrieve information about a term passed in by user (through the client program) . This function will take the keywork, and like the add function, will call the hash function to get the index of that keyword (saving the int passed back into an ‘index’ variable). Once it has the index, it will go to that index of our hash table, and traverse( if needed) until it finds the description title matching the keyword passed in. Once it has found all the matching description, it will save the information on it into a node that is passed into this function by the client program. If there is no match in this list, then this function will return 0. 
Another function I will implement will be a function to remove all the terms that are from the same, particular source. It will be passed the name of a source that the user wishes to delete the corresponding terms from their list. This function will likely have a while loop nested in a for loop. The for loop will go through each index of of the hash table (array), and each loop though it will go through a while loop to traverse through each node attached to that index. An if loop inside this while loop will test whether the source of the term of the current node is equal to the source passed into the function. If this tests true, then it will set the previous nodes next to the current nodes next, and delete the current node. ( This means I will need both a current and previous pointer, however I may be able to make this more efficient with recursion. )
Another function will be tasked with displaying all the information accompanying a particular term passed into function by user. This function will  be passed in the definition term that the user would like to view, and again this term will be sent to the hash function to find the index number. Once the index number is found, the function will traverse through all the nodes in that particular index until it finds the term matching the one passed in, then display it.
Lastly, I will implement a function to display (ALL) the definitions in the hash function. This function will have a while loop nested in a for loop. The for loop will loop through all the indexes of our hash table. And each loop through it will go through a while loop to output all the information attached to currents node, and traverse current to its next.
How each function will report success/failure back to the calling routine
Each function will be of int type and when called from main ‘catch’ the value returned (which will be a zero if the program didn't preform the action it was taked with. Any non zero number returned will inform the client program that the function was successful.
How each function will shield the client program from the details of the data structure
All the data that the user will be entering into the program will be stored into a variable ( mainly key_value ??) and passed by reference into the functions needing that information. In the case of retrieve, the function will be passed a variable by value to save the information from that function and ‘give’ back to the client program.
What data structures you will be using and how each of the special cases. Consider drawing pointer diagrams with “before” and “after” diagrams for each special cas
For this program we will be using an array of linear linked lists. I dont believe there will be any special cases (maybe if the list in a certain index is null). But since all the key values will be given an index modded with the size of the array, there shouldn't be any problems with ‘filling’ the array. Also if there are collisions, the each node is just added to the head of the list.

EFFICIENCY WRITE UP

How well did the data structure selected perform for the assigned application?
For our intended program, which involved adding a large amount of data, without caring much about the order its sorted in, I think that having an array of pointers worked well. With this data structure, I was able to create a large enough array that would allow each index of the array to be filled with few nodes (avoiding collision). And in the case a collision did occur, this data structure gives us the ability to add a node to the beginning of the linear linked list attached to that index of the hash_table array. 
Would a different data structure work better? If so, which one and why…
With a set of data as large as we’re given in this program, it's unlikely that another data structure would work as well to store ALL that data, and allow us to access a particular item in that list of data without a large amount of traversing. In the case of having an array, the amount of terms we would be allowed to add to our list would be limited to the size our array was allocated to. And in having a linear linked list, although we would have the ability to add as many terms to our list as we’d like, we would have a HUGE delay time to traverse through all that data. By using an array of linear linked lists as the data structure of our hash table, we’re able to allocate an array of size proportional to the amount of data predicted to add to our array, and easily add onto a list if two terms ‘collide’ at the same index.
What was efficient about your design and use of the data structure?
When testing my program with various hash_table_size’s, I found that when using a hash_table_size of 59, that there were only 8 index’s with collisions of two. However there were 3 index’s with collisions of three, and one with a collision of 4. I this tested out how having a size of 67 would affect the length of my chains for each index. I was able to eliminate the index with four collisions, and instead I had 1 more index with collisions of two and three. I thought this was pretty good, but I figured I would test out how the prime number in between these two looked. With a size of 61, I still only had 9 index’s with collisions of two, but the highest number of collisions I had was three, and that only occurred in two indexes. For the number of terms I’m adding from my file, this looked pretty good. However, If I knew that I would be adding a significantly larger amount of data, Im sure I would need a larger number. (Although even with a size of 61, there were many empty indexes).
What was not efficient?
I’m sure that when implementing my display function and my remove_all_source function, when I had to potentially traverse through the list until I found a match, I could have made small adjustments to improve the efficiency of the traversal through the list. 
What would you do differently if you had more time to solve the problem?
I realized that I probably could have called my retrieve function inside my display function, to find the term to display (instead of finding the term and displaying it within display, like how i implemented it). This would have made display more basic and easy to re-use, and would have put the retrieve function to better use. 


EFFICIENCY WRITE UP

How well did the data structure selected perform for the assigned application?
Overall, with the knowledge I currently have, I think that using a linear linked list, each pointing to another linear linked list works well with the objective of the program. It makes sense structurally. And unlike if we were using arrays, we have the ability to continue to add on new types of pizza. And add on to each specific pizza as many topping we wanted. I think this is really convenient for the scope of what this assignment was trying to do. If they had been limited the amount of toppings they could add to said pizza, it would really defeat the purpose of what this program was trying to do. Which was to help a user to create a list of they prefered pizza types with their prefered pizza toppings. 
Would a different data structure work better? If so, which one and why…
If this were a LLL of arrays instead, we would be limited the amount of topping we could add to a certain pizza. However It could definitely improve our efficiency being able to use pointer arithmetic. And we could always resolve the issue of memory by asking the user beforehand how many topping types they would have liked on a pizza. (although this method is less user friendly and convenient for the user.  
What was efficient about your design and use of the data structure?
I tried my best to minimize the amount of traversing I had to do. 
I also created a few general functions (like FIND, and functions to get get a pizza_types / pizza_topping from the user) that I was able to call multiple times. This saved a lot of time when building my program, and make it easier for my to test my code.
 What was not efficient?
In general, I could have probably done a better job of minimizing the amount of fetches/operations I had. Im sure the user interface part of my program could have been better. 
The data structure itself requires a lot of traversing through both lists of nodes. And although I made an attempt, Im sure my program could have done a better job avoiding traversing.
What would you do differently if you had more time to solve the problem?
Initially I wanted to be able to create my program to tell if a pizza_type or pizza_topping being passed in to add had already been added to the list. ALthough I think I was close, I had troubles getting it to work without it messing with my sorting algorithm, or having to traverse again separately just to tell if it was.
I also saw the repetition in many of the functions, with the only difference being which struct was being dealt with ( pizza_type, or pizza_topping). I think It would have been convenient to find a way to only have to create ONE function for all FIND, SORT, and DISPLAY, and just change which struct type was being used. However I foresaw many problems, such as how I would save the value of pizza_type (current) from FIND before moving onto a dealing with a specific topping from that pizza. I also was unsure of how I would go about being able to make the variables of these functions abstract enough that I would be able to change the struct type.
In general I think that my program could have been developed to be more ‘user friendly’. As it is it asks some fairly general questions (in order for me to able to re use some functions). However Im sure it would be better for the user If my program did a better job specifying what was needed, or in general asking questions more specific to what It was dealing with. 
